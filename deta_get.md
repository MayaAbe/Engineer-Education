# 組込みシステムのためのデータ取得・処理・評価入門
## ― Pythonを使った計測データ解析の第一歩 ―

## 目次

1. **第1章**：【序論】評価とは何かとデータ取得の位置づけ
* 1.1 評価の意味と人工衛星開発における重要性
* 1.2 評価から逆算するデータ取得・処理・解析の流れと全体ブロック図

2. **第2章**　PythonとCSVによるデータ解析の基礎
* 2.1 解析・可視化にはなぜ Python を使うのか
* 2.2 計測データと CSV ファイルの構造と具体例
* 2.3 Python による CSV 読み書きのイメージ
* 2.4 グラフ表現の基礎：軸ラベル・タイトル・凡例
* 2.5 グラフの種類と用途：折れ線・散布図・ヒストグラム
* 2.6 想定外のグラフにも対応する「十分なデータ取得」
* 2.7 平均・分散・標準偏差と関数の形（線形・log・exp）の直感

3. **第3章**　シチュエーション別：取得・処理・評価プロセス
* 3.1 評価項目から逆算する測定設計
* 3.2 バッテリ放電特性評価：V–t, I–t を重ねて見る
* 3.3 センサ較正・補正：散布図と一次近似，残差の評価
* 3.4 信号線・通信ログ評価：シーケンスとエラー率の解析
* 3.5 環境試験（振動・熱サイクル・真空）と試験前後比較

4. **第4章**　実装例・誤差要因・計測報告書の書き方
* 4.1 測定システム全体ブロック図と配線イメージ
* 4.2 サンプルスクリプトとグラフの重ね書き・並べ方の例
* 4.3 誤差が生まれる主な原因と簡単な誤差見積もりの考え方
* 4.4 計測報告書の構成と含めるべき項目

**付録A**　Pythonで使う主なコマンド集
* A.1 csv モジュールの基本
* A.2 pandas の基本
* A.3 matplotlib の基本
* A.4 pyserial の基本

---

## 1. 第1章：【序論】評価とは何かとデータ取得の位置づけ

### 1.1 評価の意味と人工衛星開発における重要性

本テキストで扱う中心的な概念は「評価」である。
評価とは，単に「グラフを描いて眺める」ことではなく，

> 設計段階で定めた要求・仕様に対して，実際のシステムがどの程度それを満たしているかを，データに基づいて判断すること

であると定義する。

人工衛星開発では，評価は次のような具体的な問いに対する答えと直結している。

* ミッション中の最悪条件でも，電源系は所定時間動作し続けるのか。
* 姿勢決定に使うセンサの精度は，要求される指向精度を満たすのか。
* 熱サイクル・振動・真空などの環境ストレスを加えた後も，機器は安全に動作するのか。
* 通信系のビット誤り率やエラー率は，許容値以下に抑えられているのか。

これらの問いに対して「根拠を持って Yes/No を言う」ために，
評価は設計・試験・運用のあらゆる段階で必要になる。

特に人工衛星は，一度打ち上げると物理的に修理できないことが多い。
したがって，**打ち上げ前の評価の質**が，
衛星の信頼性・安全性・ミッション成功確率を大きく左右する。

評価が不十分だと，

* 「たまたま一度だけうまく動いた結果」を過大評価し，隠れた問題を見逃したまま打ち上げる。
* 特定の環境条件（低温，真空，高振動など）での劣化や故障を見落とし，軌道上で想定外の障害が起こる。

といった事態につながる。逆に，評価が適切であれば，

* どの条件まで安全か，どの条件が危険かを定量的に把握できる。
* 必要なマージンや冗長化の設計を合理的に行える。
* 「この衛星はこの程度の確率でミッションを完遂できる」と説明できる。

本テキストで扱う「データ取得・処理・評価」は，この評価を支える基盤技術であり，
人工衛星開発エンジニアにとって中核的なスキルである。

### 1.2 評価から逆算するデータ取得・処理・解析の流れと全体ブロック図

評価はゴールであり，そこから逆算して必要なデータや処理が決まる。
典型的な流れは次の通りである。

1. 評価項目の定義（何をどの基準で良し悪し判断したいか）
2. その評価のために必要な物理量・電気量の決定
3. 測定条件・試験条件の設計
4. データ取得（測定と記録）
5. データ処理（補正，単位変換，統計量の計算など）
6. 可視化と評価（グラフ，数値指標，仕様との差の確認）

この流れを，システムのブロック図として表すと次のようになる。

```text
         [現実世界の物理量]
   温度，電圧，電流，加速度，姿勢など
                 │
                 ▼
        ┌────────────────┐
        │    センサ       │  (アナログ/デジタル信号)
        └────────────────┘
                 │
                 ▼
        ┌─────────────────────┐
        │ 組込み機器 (計測回路) │  C/C++で制御，
        │ ADC, 通信IFなど      │  データを計測・整形
        └─────────────────────┘
                 │ シリアル通信(UART/I2C/SPIなど)
                 ▼
        ┌────────────────┐
        │    PC (Python) │
        │ データ受信・保存│
        └────────────────┘
                 │ CSVファイル
                 ▼
        ┌──────────────────────┐
        │ Python解析スクリプト  │
        │ (pandas, matplotlib) │
        └──────────────────────┘
                 │ グラフ・統計量
                 ▼
        ┌────────────────┐
        │   評価・報告書  │
        └────────────────┘
```

このブロック図が，本テキスト全体の「地図」である。
以下の章では，特に PC 以降の **CSV → Python → グラフ・統計量 → 評価** の部分を中心に，
具体的なやり方・考え方を学んでいく。

---

## 2. 第2章　PythonとCSVによるデータ解析の基礎

### 2.1 解析・可視化にはなぜ Python を使うのか

組込みシステムそのものは C/C++ で制御することが多いが，
**取得したデータの解析・可視化には Python を用いることを強く推奨する**。

その理由は次の通りである。

1. **試行錯誤の速さ**
   解析やグラフの描き方を少し変えたいだけで C/C++ のプログラムをコンパイルし直すのは非効率である。
   Python ならスクリプトを数行変更するだけですぐ再実行できる。

2. **ライブラリの豊富さ**

   * 数値計算：NumPy, SciPy
   * データ処理：pandas
   * 可視化：matplotlib, plotly など
     これらを使うことで，数十行程度のコードで多彩な解析・グラフ表示ができる。

3. **再現性と共有のしやすさ**
   解析スクリプトと CSV ファイルを一緒に保存しておけば，
   他のメンバーが同じ解析を簡単に再現できる。
   Jupyter Notebook を使えば，コード・図・コメントを一体化した「解析ノート」が作成できる。

本章では，Python によるデータ解析のための **前提となるデータフォーマット（CSV）** と
**基本的な可視化のやり方** を学ぶ。

### 2.2 計測データと CSV ファイルの構造と具体例

CSV（Comma Separated Values）は，カンマ区切りのテキストファイルであり，
表形式データを簡単に扱うことができる。

#### 2.2.1 基本構造

基本的な構造は次のようになる。

```text
列名1, 列名2, 列名3, ...
値11, 値12, 値13, ...
値21, 値22, 値23, ...
...
```

多くの場合，

* **1 行目**：ヘッダ（列名）
* **2 行目以降**：各行が 1 回の観測や 1 個体のデータに対応

となる。

#### 2.2.2 具体例：バッテリ放電試験の CSV

バッテリの放電特性を見るために，時間ごとの電圧・電流・温度を記録する場合を考える。

```text
time_s, voltage_V, current_A, temp_degC
0.0,    4.20,      0.48,      25.0
0.5,    4.18,      0.47,      25.1
1.0,    4.16,      0.47,      25.2
...
```

* `time_s`：経過時間 $s$
* `voltage_V`：バッテリ電圧 $V$
* `current_A`：バッテリ電流 $A$
* `temp_degC`：バッテリ近傍温度 $℃$

#### 2.2.3 具体例：センサ較正用の CSV

温度センサの較正を行う場合，既知の真値とセンサ出力を同時に記録する。

```text
true_temp_degC, sensor_raw, sensor_voltage_V
0.0,            120,        0.50
25.0,           600,        1.80
50.0,           1080,       3.10
...
```

* `true_temp_degC`：恒温槽などで決めた真の温度 $℃$
* `sensor_raw`：ADC の生データ（カウント）
* `sensor_voltage_V`：ADC 変換前のセンサ出力電圧 $V$

#### 2.2.4 具体例：通信ログの CSV

組込み機器と地上 PC 間の通信ログを記録する場合は，方向や内容も含める。

```text
timestamp_s, direction, msg_type, payload_hex, error_flag
0.000,       TX,        CMD_SET_MODE,  "AA550101", 0
0.015,       RX,        ACK,           "06",       0
0.050,       TX,        CMD_GET_TEMP,  "AA550201", 0
0.065,       RX,        RESP_TEMP,     "1A2B",     0
0.120,       RX,        RESP_ERROR,    "E1",       1
...
```

* `direction`：`TX`（送信）か `RX`（受信）か
* `msg_type`：コマンド種別
* `payload_hex`：実際のデータ
* `error_flag`：エラー発生の有無（0 or 1）

このように，**評価で必要になりそうな情報を列として素直に持たせる**ことが重要である。

### 2.3 Python による CSV 読み書きのイメージ

詳細な使い方は付録Aで扱うが，ここではイメージだけ確認しておく。
pandas を用いると，CSV ファイルを次のような「表」として扱える。

```text
time_s | voltage_V | current_A | temp_degC
------------------------------------------
 0.0   |   4.20    |   0.48    |   25.0
 0.5   |   4.18    |   0.47    |   25.1
 1.0   |   4.16    |   0.47    |   25.2
 ...
```

この表を DataFrame と呼び，列を指定して計算やプロットを行う。
例えば「電力 $W$ = 電圧 $V$ × 電流 $A$」を新しい列として追加したりできる。

### 2.4 グラフ表現の基礎：軸ラベル・タイトル・凡例

グラフを描くとき，最低限付けるべき情報は以下の通りである。

* **軸ラベル（axis label）**

  * X 軸，Y 軸それぞれに「物理量」と「単位」を書く。
  * 例：`時間 [s]`，`電圧 [V]`，`電流 [A]` など。

* **タイトル（title）**

  * グラフが何を示すかを一言で書く。
  * 例：`バッテリ放電試験における電圧と電流の時間変化`

* **凡例（legend）**

  * 1 つの図に複数の線や点を描く場合，
    どの線が何を表しているかを区別するための表示。
  * 例：青線＝電圧，オレンジ線＝電流，灰色点＝別条件での測定結果など。

これらがないと，時間がたった後に図だけ見ても意味がわからなくなる。
特に他者と成果を共有する場面や，報告書に図を貼る場面では必須である。

### 2.5 グラフの種類と用途：折れ線・散布図・ヒストグラム

#### 2.5.1 折れ線グラフ（line plot）

* 用途：時間とともに変化する量を表示する。
* 例：

  * V–t グラフ：時間に対する電圧の変化。
  * I–t グラフ：時間に対する電流の変化。
  * T–t グラフ：時間に対する温度の変化。

これらは，**連続した時間変化**やトレンドを把握したいときに使う。

#### 2.5.2 散布図（scatter plot）

* 用途：2 つの量の関係を可視化する。
* 例：

  * 真の温度 $℃$ を横軸，センサ出力 $V$ を縦軸にとった散布図。
  * 電流 I を横軸，電圧 V を縦軸にとった V–I 特性。

散布図の点の並び方から，おおまかな関数の形（線形か，曲線か，バラバラか）を読み取ることができる。

#### 2.5.3 ヒストグラム（histogram）

* 用途：ある量の「分布」を見る。
* 例：

  * 同じ条件で 100 回測った電圧の値の分布。
  * 通信エラーが発生するまでの時間間隔の分布。

ヒストグラムの形から，ばらつきの大きさや偏り（二山になるなど）を判断できる。

#### 2.5.4 複数グラフの重ね書き・並べ方

評価では，複数の情報を同時に見る場面が多い。

* **同じ図に重ねる**

  * 例：同じ時間軸で，V–t と I–t を別々の色で描く。
  * 片側の Y 軸を電圧，もう片側を電流とする双対軸グラフもよく用いる。

* **複数の図を並べる（サブプロット）**

  * 例：左側に V–t，右側に V–I の散布図を並べる。
  * 例：上段に試験前のヒストグラム，下段に試験後のヒストグラムを並べる。

このような重ね書きや並べ方によって，「時間軸から見た評価」と「関係性から見た評価」を同時に行うことができる。

### 2.6 想定外のグラフにも対応する「十分なデータ取得」

計画段階では「V–t グラフだけ見ればよい」と考えていても，
実際にデータをとってみると「温度Tも一緒に見たい」「電流Iとの関係も見たい」
といった新たな解析のニーズが生じることが多い。

そのため，データ取得の段階では次の点を意識するとよい。

* **生データを残す**
  平均値や最大値だけを保存するのではなく，
  個々のサンプル値を保存しておくことで，後から様々な統計量やグラフを作れる。

* **時刻を必ず記録する**
  `time_s` の列があれば，他のどの列とも V–t, I–t のような折れ線グラフが描ける。

* **関連するパラメータも記録する**
  バッテリなら温度，通信なら RSSI やエラーコード，環境試験なら温度・圧力・振動レベルなど。

こうしておけば，後から新しい評価軸が必要になったときにも，
既に取得したデータを使って追加解析を行うことができる。

### 2.7 平均・分散・標準偏差と関数の形（線形・log・exp）の直感

#### 2.7.1 平均値

測定値が $x_1, x_2, \dots, x_N$ であったときの平均値 $\mu$ は

$\mu = \frac{1}{N} \sum_{i=1}^{N} x_i$

で定義される。
これは「その条件で測った値の代表値」であり，
バッテリ電圧の平均，センサの平均出力などとして用いる。

#### 2.7.2 分散・標準偏差

平均からのずれの大きさを表すのが分散・標準偏差である。
分散 $\sigma^2$ は

$\sigma^2 = \frac{1}{N} \sum_{i=1}^{N} (x_i - \mu)^2$

標準偏差 $\sigma$ はその平方根である。

* $\sigma$ が小さい → 測るたびにほぼ同じ値が出る（安定している）。
* $\sigma$ が大きい → 測るたびに値が大きく変動する（ノイズが大きい，環境変動が大きい）。

#### 2.7.3 関数の形の直感

一次関数・対数・指数など，よく出てくる関数の形を簡単に整理する。

* **線形（一次関数）**： $y=ax+b$

  * x が 2 倍になれば y もだいたい 2 倍になるような関係。
  * センサ出力の較正式として最も基本的。

* **対数関数（log）**： $y=log x$

  * x が 10 倍になるごとに y が一定量増えるような関係。
  * dB 表示や，非常に広い範囲の値を扱うときに便利。

* **指数関数（exp）**： $y=e^{ax}$

  * x を少し増やしただけで y が急激に増えることがある。
  * 劣化や充放電のモデルなどで現れる。

散布図を見たとき，「直線に近いか」「右上に行くほど急激に伸びるか」などの印象から，
どの関数形が適していそうかを感覚的に判断できると良い。

---

## 3. 第3章　シチュエーション別：取得・処理・評価プロセス

### 3.1 評価項目から逆算する測定設計

評価を行うには，まず「何を評価したいか」を決める必要がある。
この評価項目から逆算して，必要な測定やデータ処理が決まる。

評価項目 → 必要な物理量 → 測定条件 → データ取得 → 処理 → 評価
という流れを，各シチュエーションごとに具体例として見る。

### 3.2 バッテリ放電特性評価：V–t, I–t を重ねて見る

#### 3.2.1 システムブロック図

バッテリ試験のシステム構成は次のようになる。

```text
   ┌──────────┐    電圧・電流検出   ┌───────────┐
   │ バッテリ  │───────┐        ┌─▶ │  計測回路 │
   └──────────┘       │        │   │(ADC, UART)│
                      ▼        │   └───────────┘
                 ┌──────────┐  │        │UART
                 │  負荷回路 │──┘        ▼
                 └──────────┘      ┌──────────┐
                                   │PC(Python)│
                                   └──────────┘
```

計測回路 がバッテリ電圧・電流を一定周期で測定し，UART で PC に送信する。
PC 側で CSV として保存し，Python で解析する。

#### 3.2.2 取得する CSV の例

```text
time_s, voltage_V, current_A, temp_degC
0.0,    4.20,      0.48,      24.9
10.0,   4.18,      0.47,      25.0
20.0,   4.15,      0.46,      25.1
...
3600.0, 3.60,      0.40,      27.0
```

#### 3.2.3 処理とグラフ

* V–t グラフ：X 軸に `time_s`，Y 軸に `voltage_V` をとる折れ線グラフ。
* I–t グラフ：同じ X 軸に対して `current_A` を描く。
* それらを同じ図に重ねるか，双対軸を使って表示する。

V–t と I–t を重ねて見ることで，
「どのタイミングで電流が増え，それに応じて電圧がどのように落ちているか」が直感的に分かる。

#### 3.2.4 評価

* 指定された下限電圧 $V_{\text{min}}$ を V–t 曲線が下回っていないか。
* 試験条件（温度や負荷）を変えた複数の試験結果を重ねて比較し，
  どの条件で最も厳しい（マージンが小さい）かを評価する。

### 3.3 センサ較正・補正：散布図と一次近似，残差の評価

#### 3.3.1 システムブロック図

```text
┌──────────┐   アナログ値  ┌──────────┐  デジタル値   ┌──────────┐
│ 基準環境  │──────────▶   │  センサ  │──────────▶   │ 計測回路   │
│(恒温槽等) │ 真値 Ttrue   └──────────┘              │(ADC, UART)│
└──────────┘                                        └──────────┘
                                                         │UART
                                                         ▼
                                                    ┌──────────┐
                                                    │ PC(Python)│
                                                    └──────────┘
```

#### 3.3.2 CSV の例

```text
true_temp_degC, sensor_raw
0.0,            110
10.0,           310
20.0,           510
30.0,           708
40.0,           905
...
```

#### 3.3.3 散布図と一次近似

* 散布図：X 軸に `true_temp_degC`，Y 軸に `sensor_raw` をとる。
* おおむね直線に近い場合，線形モデル $y=ax+b$ を仮定する。
* 最小二乗法などで (a, b) を求める（実装は付録A参照）。

得られた較正式を使って，センサ出力から温度を推定する。

#### 3.3.4 残差とヒストグラム

各データ点について，推定値 $\hat{x}_i$ と真値 $x_i$ の差

$\text{residual}_i = x_i - \hat{x}_i$

を求める。
残差のヒストグラムを描いて，平均・標準偏差・偏りの有無を評価する。

### 3.4 信号線・通信ログ評価：シーケンスとエラー率の解析

#### 3.4.1 システムブロック図

```text
┌──────────┐    UART  ┌────────────┐
│ 地上PC    │◀────────▶│ 組込み機器 │
│ (ログ収集)│          │ (計測回路) │
└──────────┘          └────────────┘
     │                       │
  Python                  通信処理
 (pyserial)               (C/C++)
```

#### 3.4.2 CSV の例

前述の通信ログ例を再掲する。

```text
timestamp_s, direction, msg_type, payload_hex, error_flag
0.000,       TX,        CMD_SET_MODE,  "AA550101", 0
0.015,       RX,        ACK,           "06",       0
0.050,       TX,        CMD_GET_TEMP,  "AA550201", 0
0.065,       RX,        RESP_TEMP,     "1A2B",     0
0.120,       RX,        RESP_ERROR,    "E1",       1
...
```

#### 3.4.3 処理と評価

* イベントシーケンスとして，どのコマンドに対してどの応答が返ってきたかを時系列で整理する。
* `error_flag` の合計値と全メッセージ数から，エラー率を計算する。
* コマンドごとにエラー回数を集計し，特定のコマンドだけエラーが多いなどの偏りを評価する。

必要に応じて，エラー発生間隔のヒストグラムなども描いて，
エラーがランダムに発生しているのか，何らかの周期性があるのかを調べる。

### 3.5 環境試験（振動・熱サイクル・真空）と試験前後比較

#### 3.5.1 システムブロック図

ここでは熱サイクル試験を例にしたブロック図を示す。

```text
┌──────────┐  ┌──────────┐   ┌──────────┐
│ 温度チャン│  │  組込み   │  │ PC(Python)│
│バー/試験機│─▶│ システム  │─▶ │  ログ収集 │
└──────────┘  └──────────┘   └──────────┘
         ▲            │
         │            └── センサ出力，消費電流，通信ログ
   温度プロファイル
```

#### 3.5.2 試験前・中・後の CSV 構造

```text
phase, time_s, chamber_temp_degC, board_temp_degC, current_A, sensor_value
before,  0.0,  25.0,              26.0,            0.20,      1.23
before, 10.0,  25.0,              26.1,            0.20,      1.24
...
during, 100.0,  -20.0,            -15.0,           0.22,      1.30
...
after,   0.0,  25.0,              26.2,            0.21,      1.25
...
```

* `phase` 列で「試験前」「試験中」「試験後」を区別しておくと，
  同じ CSV で比較がしやすくなる。

#### 3.5.3 V–t, I–t, 温度の重ね書き

* `chamber_temp_degC`, `board_temp_degC`, `current_A` を同じ時間軸上に重ねて描き，
  温度変化に対して消費電流やセンサ値がどのように変動しているかを見る。

#### 3.5.4 前後比較と評価

* 「before」フェーズと「after」フェーズだけを抽出し，
  各フェーズで平均値・標準偏差を計算する。
* ヒストグラムや箱ひげ図を並べて表示し，
  試験前後でオフセット（平均値）やばらつき（標準偏差）が有意に変化していないかを評価する。

---

## 4. 第4章　実装例・誤差要因・計測報告書の書き方

### 4.1 測定システム全体ブロック図と配線イメージ

これまで部分的に示してきたブロック図を統合し，
一般的な計測システムの構成を改めてまとめる。

```text
           ┌─────────現実世界  ──────────┐
                                        │
   温度・振動・電圧・電流・姿勢など        │
           │                            │
           ▼                            │
   ┌──────────────┐  センサ信号  ┌────────────────┐
   │   センサ群    │────────────▶│   組込み機器    │
   │(温度,加速度等)│             │ (計測回路, ADC) │
   └──────────────┘             └────────────────┘
                                        │
                                UART/I2C/SPI など
                                        │
                                        ▼
                                 ┌──────────┐
                                 │    PC    │
                                 │ (Python) │
                                 └──────────┘
                                      │
                                   CSVファイル
                                      │
                                      ▼
                                 ┌───────────────┐
                                 │ 解析スクリプト │
                                 │  (pandas等)   │
                                 └───────────────┘
                                        │
                                 グラフ・統計量・評価
```

計測器（オシロスコープ，ロジックアナライザ，DMM）は，
この流れの中で**補助的に挿入される観測窓**と考えると理解しやすい。

### 4.2 サンプルスクリプトとグラフの重ね書き・並べ方の例

ここでは，どのようなグラフをどのように並べると評価に役立つか，
構成案だけ文章でまとめておく。

* **図1：V–t, I–t の重ね書き**

  * X 軸：`time_s`
  * Y 軸左：`voltage_V`，Y 軸右：`current_A`
  * 凡例に「電圧」「電流」を記載。
    → 放電中の電圧低下と電流変動の関係を一目で確認できる。

* **図2：温度センサ較正の散布図と一次近似**

  * 左：`true_temp_degC` vs `sensor_raw` の散布図＋回帰直線。
  * 右：残差のヒストグラム。
    → 散布図で関係の形を，ヒストグラムで誤差の大きさを評価できる。

* **図3：環境試験前後の比較**

  * 上段：試験前の `current_A` ヒストグラム。
  * 下段：試験後の `current_A` ヒストグラム。
    → 試験後にノイズや消費電流が増えていないかを視覚的に比較できる。

こうした構成をあらかじめ考えておくと，
どのような CSV 構造にすべきか，どの列が必要かも自然に決まってくる。

### 4.3 誤差が生まれる主な原因と簡単な誤差見積もりの考え方

誤差の主な原因は以下に分類できる。

1. **測定器起因**：分解能，確度，帯域幅，入力インピーダンスなど。
2. **サンプリング起因**：サンプリング周期の揺らぎ，サンプリング定理未満の測定。
3. **環境起因**：温度変動，ノイズ，振動，接触不良。
4. **ソフトウェア起因**：型変換ミス，スケーリングミス，バグ。

誤差の見積もりの例として，線形な較正式

$T = a V + b$

を使っている場合を考える。
係数 (a) と電圧 V に小さな誤差 $\Delta a, \Delta V$ があるとき，
温度推定誤差 $\Delta T$ は

$\Delta T \approx \left|\frac{\partial T}{\partial a}\right| \Delta a + \left|\frac{\partial T}{\partial V}\right| \Delta V = |V| \Delta a + |a| \Delta V$

のようにおおよそ見積もることができる。
ここでは細かい計算よりも，「測定器の仕様と計算式から誤差のオーダーを考える」
という発想を持つことが重要である。

### 4.4 計測報告書の構成と含めるべき項目

評価結果を他者と共有し，将来の自分が読み返しても理解できるようにするために，
計測報告書を作成する必要がある。構成の例を示す。

1. **タイトル・概要**

   * 例：「バッテリ放電試験報告書」
   * 試験の目的と概要を数行で記述する。

2. **目的（評価項目）**

   * 何を評価するための試験かを明記する。
   * 例：「想定ミッション負荷条件で，下限電圧 7.2 V を下回らないことを確認する」。

3. **試験条件・装置構成**

   * 使用した機器（バッテリ，負荷，計測回路，計測器，試験機）の型番・メーカー。
   * 試験環境（温度範囲，振動条件，真空度など）。
   * 本文中に簡略ブロック図や配線図を掲載する。

4. **手順**

   * 試験前・試験中・試験後に何をどの順に行ったか。
   * 繰り返し回数やサイクル数。

5. **取得データの説明**

   * CSV の列一覧と意味・単位。
   * データ数，欠損値の有無など。

6. **解析方法**

   * どのグラフをどのように描いたか。
   * どの統計量（平均，標準偏差など）を用いたか。
   * 使用したスクリプトやライブラリのバージョン。

7. **結果（図表）**

   * 代表的なグラフ（V–t, I–t, 散布図，ヒストグラムなど）。
   * 条件ごとの数値結果をまとめた表。

8. **評価・考察**

   * 仕様との比較結果（満たす／満たさない，マージン）。
   * 異常値や外れ値の有無とその解釈。
   * 想定外の挙動が見られた場合の仮説と今後の対策案。

9. **結論**

   * 試験全体として何が分かったかを簡潔にまとめる。

10. **付録**

    * 追加の図表，サンプルデータの抜粋。
    * 使用した解析スクリプトの一覧。

このような構成にすることで，
単なる「グラフ集」ではなく，「評価のプロセス全体がわかる文書」を作ることができる。

---

## 付録A　Pythonで使う主なコマンド集

ここでは，本テキストで前提とした Python の機能について，
具体的なコマンドの使い方を簡単にまとめる。

### A.1 csv モジュールの基本

標準ライブラリ `csv` を用いて，
簡単な CSV の読み書きを行うことができる。

**読み込みの例**

```python
import csv

with open("data.csv", newline="", encoding="utf-8") as f:
    reader = csv.reader(f)
    header = next(reader)  # 1行目のヘッダ
    for row in reader:
        # row は $'0.0', '4.20', '0.48'$ のようなリスト
        time_s = float(row$0$)
        voltage = float(row$1$)
        current = float(row$2$)
        # ここで処理を書く
```

**書き込みの例**

```python
import csv

rows = $
    $"time_s", "voltage_V", "current_A"$,
    $0.0, 4.20, 0.48$,
    $0.5, 4.18, 0.47$,
$

with open("out.csv", "w", newline="", encoding="utf-8") as f:
    writer = csv.writer(f)
    writer.writerows(rows)
```

### A.2 pandas の基本

pandas は表形式データ（DataFrame）を扱うためのライブラリである。

**CSV の読み込み**

```python
import pandas as pd

df = pd.read_csv("battery_log.csv")
# 列にアクセス
t = df$"time_s"$
v = df$"voltage_V"$
i = df$"current_A"$
```

**新しい列の追加**

```python
df$"power_W"$ = df$"voltage_V"$ * df$"current_A"$
```

**フィルタリングの例**

```python
# 電圧が 3.7 V 未満の行だけ抽出
low_v = df$df$"voltage_V"$ < 3.7$
```

**統計量の計算**

```python
mean_v = df$"voltage_V"$.mean()
std_v = df$"voltage_V"$.std()
```

### A.3 matplotlib の基本

matplotlib は Python の標準的な可視化ライブラリである。

**折れ線グラフ（V–t）の例**

```python
import matplotlib.pyplot as plt

plt.figure()
plt.plot(df$"time_s"$, df$"voltage_V"$, label="Voltage")
plt.xlabel("Time $s$")
plt.ylabel("Voltage $V$")
plt.title("Battery Voltage vs Time")
plt.legend()
plt.grid(True)
plt.show()
```

**V–t と I–t を同じ図に重ねる例（双対軸）**

```python
fig, ax1 = plt.subplots()

ax1.set_xlabel("Time $s$")
ax1.set_ylabel("Voltage $V$")
ax1.plot(df$"time_s"$, df$"voltage_V"$, label="Voltage")

ax2 = ax1.twinx()
ax2.set_ylabel("Current $A$")
ax2.plot(df$"time_s"$, df$"current_A"$, color="orange", label="Current")

fig.suptitle("Voltage and Current vs Time")
fig.tight_layout()
plt.show()
```

**散布図の例（センサ較正）**

```python
plt.figure()
plt.scatter(df$"true_temp_degC"$, df$"sensor_raw"$, s=10)
plt.xlabel("True Temperature $degC$")
plt.ylabel("Sensor Raw $counts$")
plt.title("Sensor Calibration Scatter Plot")
plt.grid(True)
plt.show()
```

**ヒストグラムの例**

```python
plt.figure()
plt.hist(df$"voltage_V"$, bins=30)
plt.xlabel("Voltage $V$")
plt.ylabel("Count")
plt.title("Voltage Distribution")
plt.grid(True)
plt.show()
```

### A.4 pyserial の基本

pyserial はシリアル通信を扱うためのライブラリである。

**ポートオープンと行単位の読み取り**

```python
import serial
import time

ser = serial.Serial(
    port="COM3",       # Linuxなら "/dev/ttyUSB0" 等
    baudrate=115200,
    timeout=1.0
)

with open("log.csv", "w", encoding="utf-8") as f:
    f.write("time_s, value1, value2\n")
    start = time.time()

    while True:
        line = ser.readline().decode("utf-8").strip()
        if not line:
            continue
        now = time.time() - start
        # ここでは "123,456" のような形式を想定
        f.write(f"{now},{line}\n")
        f.flush()
```

**送信の例**

```python
ser.write(b"START\n")
```

---

本付録はあくまで最小限のリファレンスであり，
実際に勉強会や演習で用いる際には，
ここに挙げたコマンドをベースに，対象とするプロジェクトに合わせたスクリプトを発展させていくとよい。

